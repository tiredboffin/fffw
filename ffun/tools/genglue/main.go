package main

import (
    "bufio"
    "fmt"
    "os"
    "path/filepath"
    "strings"
)


const modulePath = "ffun"
const manifestPath = ".gengenerated" 


func main() {
    cliDir := "internal/cli"
    cmdDir := "cmd"

    var registryImports []string
    var registryEntries []string
    var helpEntries []string

    var generated []string

    entries, _ := os.ReadDir(cliDir)
    for _, e := range entries {
	if !e.IsDir() || strings.HasPrefix(e.Name(), "_") {
	    continue
	}

	name := e.Name()

	// --- Generate cmd/programX/main.go ---
	mainDir := filepath.Join(cmdDir, name)
	_ = os.MkdirAll(mainDir, 0755)
	mainFile := filepath.Join(mainDir, "main.go")

	if _, err := os.Stat(mainFile); os.IsNotExist(err) {
	    mainSrc := fmt.Sprintf(`// Code generated by tools/genglue. DO NOT EDIT.

package main

import (
    "os"
    "%s/internal/cli/%s"
)

func main() {
    %s.Run(os.Args[1:])
}
`, modulePath, name, name)
	    _ = os.WriteFile(mainFile, []byte(mainSrc), 0644)
	    generated = append(generated, mainFile)
	    fmt.Println("Generated:", mainFile)
	}

	// --- Collect entries for registry ---
	registryImports = append(registryImports,
	    fmt.Sprintf("\t%sPkg \"%s/internal/cli/%s\"", name, modulePath, name))
	registryEntries = append(registryEntries,
	    fmt.Sprintf("\t\"%s\": %sPkg.Run,", name, name))
	helpEntries = append(helpEntries,
	    fmt.Sprintf("\t\"%s\": %sPkg.Help,", name, name))
    }

    // --- Generate internal/cli/registry_gen.go ---
    regFile := filepath.Join(cliDir, "registry_gen.go")
    regSrc := `// Code generated by tools/genglue. DO NOT EDIT.

package cli

import (
` + strings.Join(registryImports, "\n") + `
)

var Registry = map[string]func([]string){
` + strings.Join(registryEntries, "\n") + `
}

var HelpText = map[string]func()(string){
` + strings.Join(helpEntries, "\n") + `
}
`
    err := os.WriteFile(regFile, []byte(regSrc), 0644)
    generated = append(generated, regFile)
    if err != nil {
	fmt.Println("Error writing registry_gen.go:", err)
	os.Exit(1)
    }
    // Load existing manifest entries (if any)
    manifestSet := map[string]bool{}
    if f, err := os.Open(manifestPath); err == nil {
	scanner := bufio.NewScanner(f)
        for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line != "" {
		    manifestSet[line] = true
		}
	    }
        f.Close()
    }
    // Add new generated paths
    for _, path := range generated {
        manifestSet[filepath.ToSlash(path)] = true // normalize slashes
    }

    // Write merged manifest
    f, err := os.Create(manifestPath)
    if err != nil {
	panic("failed to write .gengenerated: " + err.Error())
    }
    defer f.Close()

    for path := range manifestSet {
	f.WriteString(path + "\n")
    }
    fmt.Println("Generated:", regFile)
}
